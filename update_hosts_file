#!/usr/bin/perl -w

# Update the /etc/hosts file to include all of the IP address in the piped input.

use Getopt::Std;

my $config;
if (-e ".under_siege") {
	$config = ".under_siege";
} elsif (-e "$ENV{HOME}/.under_siege") {
	$config = "$ENV{HOME}/.under_siege";
} else {
	print STDERR "No configuration found in either of\n";
	print STDERR "\t.under_siege\n\t$ENV{HOME}/.under_siege\n";
	print STDERR "\nConfiguration should include a definition of \$IP such as:\n\t\$IP = '140.233.4.221';\n\n";
	exit(1);
}

do $config;

if (!defined($IP)) {
	print STDERR "\$IP was not defined in $config\n";
	print STDERR "\nConfiguration should include a definition of \$IP such as:\n\t\$IP = '140.233.4.221';\n\n";
	exit(3);
}
if ($IP !~ /^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$/) {
	print STDERR "Invalid IP address `$IP` defined in $config\n";
	print STDERR "\nConfiguration should include a definition of \$IP such as:\n\t\$IP = '140.233.4.221';\n\n";
	exit(3);
}
my $ipRegex = "^".$IP;
$ipRegex =~ s/\./\\./g;

# Accept arguments from the command line.
getopts ('yn');
if ($opt_y && $opt_y) {
	$YES_FOR_ALL = 1;
}
if ($opt_n && $opt_n) {
	$YES_FOR_ALL = -1;
}
if (!defined($YES_FOR_ALL)) {
	$YES_FOR_ALL = 0;
}

use Tie::File;

sub in_array
 {
     my ($arr,$search_for) = @_;
     my %items = map {$_ => 1} @$arr;
     return (exists($items{$search_for}))?1:0;
 }
 
sub prompt_user {
  my($prompt, $default) = @_;
  my $defaultValue = $default ? "[$default]" : "";
  open TTY, '<', '/dev/tty';
  print "$prompt $defaultValue: ";
  chomp(my $input = <TTY>);
  close TTY;
  return $input ? $input : $default;
}

tie @hostsFile, 'Tie::File', '/etc/hosts' or die "Couldn't open /etc/hosts";

# Find the start of our host list, ignoring any hosts listed before.
foreach my $i (0..$#hostsFile) {
	if ($hostsFile[$i] =~ /# under siege hosts/) {
		$hostMarker = $i;
	}
}
if (!defined($hostMarker)) {
	$hostMarker = scalar(@hostsFile);
	push(@hostsFile, "# under siege hosts");
}

my @hosts = ();
while (<STDIN>) {
	my $host = $_;
	$host =~ s/\n//;
	if ($host =~ /^[a-z0-9\.]+$/) {
		push(@hosts, $host);
	}
}
close STDIN;

# Add or update hosts
foreach $host (@hosts) {
	my $hostRegex = $host;
	my $found = 0;
	$hostRegex =~ s/\./\\./g;
# 	print "`$hostRegex`\n";
	foreach my $j (($hostMarker + 1)..$#hostsFile) {
		if ($hostsFile[$j] =~ /$hostRegex/) {
			$found = 1;
			
			# check IP
			if ($hostsFile[$j] !~ /$ipRegex/) {
				if ($YES_FOR_ALL == 0) {
					$update = prompt_user("Update IP to `$IP	$host` in /etc/hosts? (y/n)", 'y');
				} elsif ($YES_FOR_ALL < 0) {
					print "Update IP to `$IP	$host` in /etc/hosts? (y/n): n\n";
					$update = 'n';
				}
				if ($YES_FOR_ALL > 0 || $update =~ /^y/) {
					$hostsFile[$j] = "$IP	$host";
					print STDERR "Updated IP to `$IP	$host` in /etc/hosts\n";
				}
			}
			last;
		}
	}
	
	# Add
	if (!$found) {
		if ($YES_FOR_ALL == 0) {
			$update = prompt_user("Add `$IP	$host` to /etc/hosts? (y/n)", 'y');
		} elsif ($YES_FOR_ALL < 0) {
			print "Add `$IP	$host` to /etc/hosts? (y/n): n\n";
			$update = 'n';
		}
		if ($YES_FOR_ALL > 0 || $update =~ /^y/) {
			push(@hostsFile, "$IP	$host");
			print STDERR "Added `$IP	$host` to /etc/hosts\n";
		}
	}
}

# Remove unneeded hosts
my $j = $hostMarker + 1;
while ($j < scalar(@hostsFile)) {
	if ($hostsFile[$j] =~ /^[0-9\.]+\s+([a-z0-9\.]+)$/) {
		if (in_array(\@hosts, $1)) {
			$j++;
		} else {
			if ($YES_FOR_ALL == 0) {
				$update = prompt_user("Remove `".$hostsFile[$j]."` from /etc/hosts? (y/n)", 'y');
			} elsif ($YES_FOR_ALL < 0) {
				print "Remove `".$hostsFile[$j]."` from /etc/hosts? (y/n): n\n";
				$update = 'n';
			}
			if ($YES_FOR_ALL > 0 || $update =~ /^y/) {
				print STDERR "Removed `".$hostsFile[$j]."` from /etc/hosts\n";
				splice(@hostsFile, $j, 1);
			} else {
				$j++;
			}
			
		}
	} else {
		$j++;
	}
}

untie @hostsFile

